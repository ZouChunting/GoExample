package main

import (
	"fmt"
	"os"
)

//41.panic   恐慌？？？
//我发现go语言是个起名鬼才
//虽然这里还没讲到，但是有必要介绍一下
//go语言追求简洁优雅，所以，go语言不支持传统的try...catch...finally这种异常，因为go语言的设计者认为，将异常与控制结构混在
//一起会很容易使得代码变得混乱。因为开发者的很容易滥用异常，甚至以一个小小的错误都抛出一个异常。在go语言中，使用多值返回来返回错误。
//不要用异常代替错误，更不要用来控制流程。在极个别的情况下，也就是说，遇到真正的异常的情况下（比如除数为0）。才使用go中引入的
//Exception处理：defer,panic,recover
//这几个异常的使用场景可以简单的描述为：go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理
//我现在学的不深，也不是很能理解这种异常处理方式是不是更好
//panic是用来表示非常严重的不可恢复的错误的。
//在go语言这是一个内置函数，接收一个interface{}类型的值（也就是任何值）作为参数
//panic的作用就像我们平常接触的异常。不过go没有try...catch...，所以，panic一般会导致程序挂掉，除非recover
//调用panic程序立马挂掉，然后go运行时会打印调出栈

func main()  {
	panic("a problem")
	//注意观察一下加了这行panic代码，下面不管写什么在ide goland中都会标黄。
	//再对比一下打印结果，这个panic是个狠人，它抛出了一个真正的异常
	_,err:=os.Create("/tmp/file")   //这个函数是创建文件用的，当然了，在这种情况下，是不会执行的了
	if err!=nil{
		panic(err)
	}
	fmt.Println("2345")
}
//运行此程序将导致其出现紧急情况，打印错误消息和协程跟踪，并以非0状态退出
